const axios = require('axios');
const Schedule = require('./models/Schedule'); // Schedule schema for saving schedules
// const BOM = require('../models/BOM');
const mongoose = require('mongoose');

// Fetch data from third-party APIs
const fetchOrders = async () => {
  const response = await axios.get('https://kera-internship.onrender.com/order');
  return response.data;
};

const fetchBOM = async () => {
  const response = await axios.get('https://kera-internship.onrender.com/machine');
  return response.data;
};

const fetchMachines = async () => {
  const response = await axios.get('https://kera-internship.onrender.com/schedule');
  return response.data;
};

// Helper function to create recommendation entries
const createRecommendation = (type, reason) => {
  return {
    type,
    reason,
    suggestedBy: 'System',
    createdAt: new Date(),
  };
};

// Auto-schedule function using third-party APIs
const autoSchedule = async () => {
  const orders = await fetchOrders();
  const bomData = await fetchBOM();
  const machines = await fetchMachines();

  const recommendations = [];

  for (let order of orders) {
    // STEP 1: Identify final BOM stage (LABELLING & PACKING) containing the order item
    const finalStage = bomData.find(
      bom =>
        bom.process.toUpperCase() === 'LABELLING & PACKING' &&
        bom.components.some(comp => comp.name === order.itemCode)
    );

    if (!finalStage) {
      recommendations.push(createRecommendation('No BOM Found', `No BOM path found for item ${order.itemCode}`));
      continue;
    }

    // STEP 2: Recursively get all BOM stages leading to the final product
    const stages = [];
    const visited = new Set();
    const collectStages = (currentName) => {
      const stage = bomData.find(bom => bom.name === currentName && !visited.has(bom._id));
      if (stage) {
        visited.add(stage._id);
        if (Array.isArray(stage.components)) {
          for (const comp of stage.components) {
            collectStages(comp.name);
          }
        }
        stages.unshift(stage); // Add in reverse order to process from first stage
      }
    };
    collectStages(finalStage.name);

    // STEP 3: Schedule each stage
    let startTime = new Date();
    for (let stage of stages) {
      const availableMachines = machines.filter(
        m => m.process?.toLowerCase() === stage.process.toLowerCase() && m.status==="idle"
      );

      if (availableMachines.length === 0) {
        const recommendation = createRecommendation('Outsource', `No available machines for ${stage.process}`);
        recommendations.push(recommendation);

        // Save schedule with recommendation
        const scheduleEntry = new Schedule({
          orderID: order._id,
         
          machineID: null, // No machine, outsourcing
          stageName: stage.process,
          scheduledStart: startTime,
          scheduledEnd: new Date(startTime.getTime() + 1 * 60 * 60 * 1000), // Placeholder end time
          quantity: order.quantity,
          uom: order.uom,
          status: 'Pending Approval', // Pending approval as outsourcing
          recommendation, // Embedded recommendation here
        });

        await scheduleEntry.save();
        continue;
      }

      const machine = availableMachines[0]; // Pick first available machine
      const batchSize = stage.batch_size || 1;
      const timeForBatch = stage.timeForOneBatch || 1;
      const batches = Math.ceil((order.quantity * stage.unitMaterialPerProduct) / batchSize);

      for (let i = 0; i < batches; i++) {
        const endTime = new Date(startTime.getTime() + timeForBatch * 60 * 60 * 1000);

        // Check if machine capacity is exceeded
        const machineCapacity = 8*2;
        const requiredCapacity = timeForBatch * batches;

        if (requiredCapacity > machineCapacity) {
          const recommendation = createRecommendation('Extra Shift', `Capacity exceeded for ${stage.process} on machine ${machine.machineName}. Recommend extra shift.`);
          recommendations.push(recommendation);

          // Save schedule with recommendation
          const scheduleEntry = new Schedule({
            orderID: order._id,
            machineID: machine._id,
            stageName: stage.process,
            scheduledStart: startTime,
            scheduledEnd: endTime,
            quantity: order.quantity,
            uom: order.uom,
            status: 'Pending Approval', // Pending approval for extra shift
            recommendation, // Embedded recommendation here
          });

          await scheduleEntry.save();
        } else {
          // Save the regular schedule entry
          const scheduleEntry = new Schedule({
            orderID: order._id,
            machineID: machine._id,
            stageName: stage.process,
            scheduledStart: startTime,
            scheduledEnd: endTime,
            quantity: order.quantity,
            uom: order.uom,
            status: 'Scheduled', // Normal status
            recommendation: null, // No recommendation
          });

          await scheduleEntry.save();
        }

        startTime = new Date(endTime); // Next batch starts after this one
      }
    }
  }

  return recommendations; // Optional, if you want to return recommendations separately
};

module.exports = { autoSchedule };
